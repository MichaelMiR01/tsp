!!!!! assigning a var from a command with the same var has deallocation error:
      perhaps only a problem on vars from arguments?

tsp::proc foo3 {l i} {
    #tsp::procdef returns: var args: var int
    set l [lindex $l $i]
    return $l
}


this also an error; perhaps is has to do with TclList?
tsp::proc foo4 {l i} {
    #tsp::procdef returns: int args: var int
    set v [lindex $l $i]
    return $i
}



0. what to do with unset?  - probably generate a compile error.
0. add 'preparse' so that command with vars that need to be volaile are spilled and loaded..
   prob not needed.  just have commands that use 'varname' check if varname was in volatile list, if
   not, then spill var, and then add to volatile list in order to have it reloaded.



0. PROB NOT (just let gc do it's job on new generation) declare shadow vars as static, to reuse.  shadow vars not released at end of code body.  Command proc
   should implement CommandWithDispose so that shadow vars can be collected

1. PROB NOT (same as above) tcl direct & indirect: use shadow vars if recursive count == 1, otherwise use per-invocation tmpVars (on
   stack)

2. allocate tcl direct arrays for each number of arguments, or allocate largest used and Arrays.copyRangeOf() 
   to get the size needed for smaller sizes.

3. NO- for tcl indirect, perhaps builds array, then use Arrays.asList to get a list, 
   instead of allocating a new TclObject list.

4. on volatile reload, get or duplicate tcl variable into shadow var and reload native from that (saves dirty
   step).

5. DONE-(fixed in genereted code) interp.newCallFrame() needs to be public, and/or add new CallFrame constructor to hook into interp
   with minimal fuss.

6. parsing ::tsp::procdef - allow missing 'args:' if arglist is empty.  Or, should we force empty args as "void"??



30. implement: expr list, lxxxxx, string, concat, append, join

40. implement simple case of: scan, format
